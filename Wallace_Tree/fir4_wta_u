module fir4_wta_u #(parameter w=16)(
  input                     clk,
                            reset,
  input         [w-1:0]    a,
  output logic  [w+1:0]    s
);

  // Delay pipeline for input a
  logic [w-1:0] ar, br, cr, dr;

  // --------------------------
  // Wallace Tree combinational
  // --------------------------
  // Reduce 4 operands (ar, br, cr, dr) to 2 using full adders
  // Then use final fast adder
  // --------------------------
  
  logic [w-1:0] sum_level1, carry_level1;
  logic [w-1:0] sum_level2, carry_level2;
  logic [w:0]   sum1, sum2;
  logic [w+1:0] sum_comb;

  always_comb begin
    // --------------------------
    // Level 1: Reduce 4 operands to 2 rows (column-wise)
    // For each bit i, use full adders
    // sum_level1 = sum bits, carry_level1 = carry to next column
    // --------------------------
    sum_level1[0]   = ar[0] ^ br[0] ^ cr[0];
    carry_level1[0] = (ar[0] & br[0]) | (br[0] & cr[0]) | (ar[0] & cr[0]);

    sum_level1[1+:w-1]   = { (w-1){1'b0} };
    carry_level1[1+:w-1] = { (w-1){1'b0} };

    for(int i=1; i<w; i++) begin
      logic [2:0] bits = {ar[i], br[i], cr[i]};
      sum_level1[i]   = bits[0] ^ bits[1] ^ bits[2];
      carry_level1[i] = (bits[0]&bits[1]) | (bits[1]&bits[2]) | (bits[0]&bits[2]);
    end

    // Add the 4th operand (dr) to the reduced sum_level1 and carry_level1
    sum_level2[0]   = sum_level1[0] ^ dr[0];
    carry_level2[0] = (sum_level1[0] & dr[0]) | carry_level1[0];

    for(int i=1; i<w; i++) begin
      sum_level2[i]   = sum_level1[i] ^ dr[i] ^ carry_level1[i-1];
      carry_level2[i] = (sum_level1[i] & dr[i]) | (dr[i] & carry_level1[i-1]) | (sum_level1[i] & carry_level1[i-1]);
    end

    // --------------------------
    // Level 2: final addition of two rows (sum_level2 + carry_level2 shifted)
    // --------------------------
    sum1 = {1'b0, sum_level2};                  // lower row
    sum2 = {carry_level2[w-1:0], 1'b0};        // upper row (carry shifted by 1)
    sum_comb = sum1 + sum2;                     // final fast addition
  end

  // --------------------------
  // Sequential logic
  // --------------------------
  always_ff @(posedge clk) begin
    if(reset) begin
      ar <= 'b0; br <= 'b0; cr <= 'b0; dr <= 'b0;
      s  <= 'b0;
    end
    else begin
      ar <= a;
      br <= ar;
      cr <= br;
      dr <= cr;
      s  <= sum_comb;
    end
  end

endmodule
